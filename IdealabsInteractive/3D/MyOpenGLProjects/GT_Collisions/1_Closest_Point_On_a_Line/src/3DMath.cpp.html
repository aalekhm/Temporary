<html>
<head>
<style>
.keyword{color:rgb(0,0,255);}
.comment{color:rgb(0,128,0);}
.pp{color:rgb(0,0,255);}
</style>
<body>
<pre style="font-family:courier;font-size:10pt"><span class=comment>//***********************************************************************//
</span><span class=comment>//                                                                         //
</span><span class=comment>//        - &quot;Talk to me like I'm a 3 year old!&quot; Programming Lessons -         //
</span><span class=comment>//                                                                       //
</span><span class=comment>//        $Author:        DigiBen            DigiBen@GameTutorials.com         //
</span><span class=comment>//                                                                         //
</span><span class=comment>//        $Program:        ClosestPointOnLine                                 //
</span><span class=comment>//                                                                         //
</span><span class=comment>//        $Description:    Finds closest point on a line to another point     //
</span><span class=comment>//                                                                         //
</span><span class=comment>//        $Date:            2/23/02                                             //
</span><span class=comment>//                                                                         //
</span><span class=comment>//***********************************************************************//
</span>
<span class=pp>#include</span> &quot;main.h&quot;
<span class=pp>#include</span> &lt;math.h&gt;    <span class=comment>// We include math.h so we can use the sqrt() function
</span>

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span><span class=comment>//
</span><span class=comment>// This tutorial was sort of built from the first collision tutorial of a line and plane.
</span><span class=comment>// Functions were take out that had to deal with collision because they were not used
</span><span class=comment>// in this tutorial.  We added 2 more important math functions to our math library:
</span><span class=comment>// 
</span><span class=comment>// // This returns the distance from 2 3D points 
</span><span class=comment>// float Distance(CVector3 vPoint1, CVector3 vPoint2);
</span><span class=comment>//
</span><span class=comment>// // This returns the point on a line segment that is closest to a given 3D point
</span><span class=comment>// CVector3 ClosetPointOnLine(CVector3 vA, CVector3 vB, CVector3 vPoint)
</span><span class=comment>//
</span><span class=comment>// These functions allow us to find the closest point on a line segment from a given point.
</span><span class=comment>// This is used in collision detection and a few other cases.
</span><span class=comment>//
</span><span class=comment>//
</span>

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>

<span class=comment>/////////////////////////////////////// MAGNITUDE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This returns the magnitude of a normal (or any other vector)
</span><span class=comment>/////
</span><span class=comment>/////////////////////////////////////// MAGNITUDE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>
<span class=keyword>float</span> Magnitude(CVector3 vNormal)
{
    <span class=comment>// This will give us the magnitude or &quot;Norm&quot; as some say, of our normal.
</span>    <span class=comment>// Here is the equation:  magnitude = sqrt(V.x^2 + V.y^2 + V.z^2)  Where V is the vector
</span>
    <span class=keyword>return</span> (<span class=keyword>float</span>)sqrt( (vNormal.x * vNormal.x) + (vNormal.y * vNormal.y) + (vNormal.z * vNormal.z) );
}


<span class=comment>/////////////////////////////////////// NORMALIZE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This returns a normalize vector (A vector exactly of length 1)
</span><span class=comment>/////
</span><span class=comment>/////////////////////////////////////// NORMALIZE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>
CVector3 Normalize(CVector3 vNormal)
{
    <span class=keyword>float</span> magnitude = Magnitude(vNormal);                <span class=comment>// Get the magnitude of our normal
</span>
    <span class=comment>// Now that we have the magnitude, we can divide our normal by that magnitude.
</span>    <span class=comment>// That will make our normal a total length of 1.  This makes it easier to work with too.
</span>
    vNormal.x /= magnitude;                                <span class=comment>// Divide the X value of our normal by it's magnitude
</span>    vNormal.y /= magnitude;                                <span class=comment>// Divide the Y value of our normal by it's magnitude
</span>    vNormal.z /= magnitude;                                <span class=comment>// Divide the Z value of our normal by it's magnitude
</span>
    <span class=comment>// Finally, return our normalized normal.
</span>
    <span class=keyword>return</span> vNormal;                                        <span class=comment>// Return the new normal of length 1.
</span>}

<span class=comment>/////////////////////////////////// DOT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This computers the dot product of 2 vectors
</span><span class=comment>/////
</span><span class=comment>/////////////////////////////////// DOT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>
<span class=keyword>float</span> Dot(CVector3 vVector1, CVector3 vVector2) 
{
    <span class=comment>// The dot product is this equation: V1.V2 = (V1.x * V2.x  +  V1.y * V2.y  +  V1.z * V2.z)
</span>    <span class=comment>// In math terms, it looks like this:  V1.V2 = ||V1|| ||V2|| cos(theta).
</span>    <span class=comment>// It returns the distance of the projected vector, vVector2, from the start of vVector1.
</span>    
             <span class=comment>//    (V1.x * V2.x        +        V1.y * V2.y        +        V1.z * V2.z)
</span>    <span class=keyword>return</span> ( (vVector1.x * vVector2.x) + (vVector1.y * vVector2.y) + (vVector1.z * vVector2.z) );
}


<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>
<span class=comment>/////////////////////////////////// DISTANCE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This returns the distance between 2 3D points
</span><span class=comment>/////
</span><span class=comment>/////////////////////////////////// DISTANCE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>
<span class=keyword>float</span> Distance(CVector3 vPoint1, CVector3 vPoint2)
{
    <span class=comment>// This is the classic formula used in beginning algebra to return the
</span>    <span class=comment>// distance between 2 points.  Since it's 3D, we just add the z dimension:
</span>    <span class=comment>// 
</span>    <span class=comment>// Distance = sqrt(  (P2.x - P1.x)^2 + (P2.y - P1.y)^2 + (P2.z - P1.z)^2 )
</span>    <span class=comment>//
</span>    <span class=keyword>double</span> distance = sqrt( (vPoint2.x - vPoint1.x) * (vPoint2.x - vPoint1.x) +
                            (vPoint2.y - vPoint1.y) * (vPoint2.y - vPoint1.y) +
                            (vPoint2.z - vPoint1.z) * (vPoint2.z - vPoint1.z) );

    <span class=comment>// Return the distance between the 2 points
</span>    <span class=keyword>return</span> (<span class=keyword>float</span>)distance;
}


<span class=comment>////////////////////////////// CLOSET POINT ON LINE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This returns the point on the line vA_vB that is closest to the point vPoint
</span><span class=comment>/////
</span><span class=comment>////////////////////////////// CLOSET POINT ON LINE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>
CVector3 ClosestPointOnLine(CVector3 vA, CVector3 vB, CVector3 vPoint)
{
    <span class=comment>// This function takes a line segment, vA to vB, then a point, vPoint.
</span>    <span class=comment>// We want to find the closet point on the line segment to our vPoint
</span>    <span class=comment>// out in space.  Either it is going to be one of the end points of the line,
</span>    <span class=comment>// or it is going to be somewhere between vA and vB.  This is a important
</span>    <span class=comment>// function when dealing with collision detection.
</span>
    <span class=comment>// Here is how it works, it's a bit confusing at first, so you will need
</span>    <span class=comment>// to contemplate it a bit.  First, we want to grab a vector from &quot;vA&quot; to the point.
</span>    <span class=comment>// Then we want to get a normalized vector from &quot;vA&quot; to &quot;vB&quot;.  We don't need the
</span>    <span class=comment>// full length of the line segment vector, we just want a direction.  That is why 
</span>    <span class=comment>// we normalize it.  Remember, this is important because we are going to be using 
</span>    <span class=comment>// the dot product coming up next.  So, now we have 2 vectors that form a pseudo corner
</span>    <span class=comment>// of a triangle on the plane of the line segment and the point.
</span>    <span class=comment>//
</span>    <span class=comment>// Next, we want to find the distance or &quot;magnitude&quot; of the line segment.  This is
</span>    <span class=comment>// done with a simple distance formula.  Then we use the dot &quot;vVector2&quot; with &quot;vVector1&quot;.
</span>    <span class=comment>// By using the dot product, we can essentially project vVector1 onto the
</span>    <span class=comment>// line segments normalized vector, &quot;vVector2&quot;.  If the result of the dot product is
</span>    <span class=comment>// 0, that means the vectors were perpendicular and had a 90 degree angle between them.
</span>    <span class=comment>// The 0 part is the distance the new projected vector is from the starting of vVector2.
</span>    <span class=comment>// If the result is a negative number, that means the angle between the 2 vectors
</span>    <span class=comment>// is greater than 90 degrees, which means that the closest point must be &quot;vA&quot; because
</span>    <span class=comment>// it's projected vector is on the outside of the line.  So, if the result is a positive
</span>    <span class=comment>// number, the projected vector is on the right side of &quot;vA&quot;, but could be past the right
</span>    <span class=comment>// side of vB.  To test this, we make sure that the result of the dot product is NOT
</span>    <span class=comment>// greater than the distance &quot;d&quot;.  If it is, then the closest point on the plane is
</span>    <span class=comment>// obviously vB.  
</span>    <span class=comment>//
</span>    <span class=comment>// So, we can find the closest point easily if it's one of the end points of the line
</span>    <span class=comment>// segment, but how do we find the point between the 2 end points?  This is simple.
</span>    <span class=comment>// Since we have the distance &quot;t&quot; from point &quot;vA&quot; (given to us from the dot product 
</span>    <span class=comment>// of the 2 vectors), we just use our vector that is going the direction of the
</span>    <span class=comment>// line segment, &quot;vVector2&quot;, and multiply it by the distance scalar &quot;t&quot;.  This will
</span>    <span class=comment>// create a vector going in the direction of the line segment, with a distance
</span>    <span class=comment>// (or magnitude) of the projected vector, &quot;vVector1&quot;, is from from &quot;vA&quot;.  We then add
</span>    <span class=comment>// this vector to &quot;vA&quot;, which gives us the point on the line that is closest to our
</span>    <span class=comment>// point out in space, vPoint!  
</span>    <span class=comment>//
</span>    <span class=comment>// This is probably pretty hard to visualize with just comments, unless you have a good 
</span>    <span class=comment>// grasp of linear algebra.  
</span>    
    <span class=comment>// Create the vector from end point vA to our point vPoint.
</span>    CVector3 vVector1 = vPoint - vA;

    <span class=comment>// Create a normalized direction vector from end point vA to end point vB
</span>    CVector3 vVector2 = Normalize(vB - vA);

    <span class=comment>// Use the distance formula to find the distance of the line segment (or magnitude)
</span>    <span class=keyword>float</span> d = Distance(vA, vB);

    <span class=comment>// Using the dot product, we project the vVector1 onto the vector vVector2.
</span>    <span class=comment>// This essentially gives us the distance from our projected vector from vA.
</span>    <span class=keyword>float</span> t = Dot(vVector2, vVector1);

    <span class=comment>// If our projected distance from vA, &quot;t&quot;, is less than or equal to 0, it must
</span>    <span class=comment>// be closest to the end point vA.  We want to return this end point.
</span>    <span class=keyword>if</span> (t &lt;= 0) 
        <span class=keyword>return</span> vA;

    <span class=comment>// If our projected distance from vA, &quot;t&quot;, is greater than or equal to the magnitude
</span>    <span class=comment>// or distance of the line segment, it must be closest to the end point vB.  So, return vB.
</span>    <span class=keyword>if</span> (t &gt;= d) 
        <span class=keyword>return</span> vB;
 
    <span class=comment>// Here we create a vector that is of length t and in the direction of vVector2
</span>    CVector3 vVector3 = vVector2 * t;

    <span class=comment>// To find the closest point on the line segment, we just add vVector3 to the original
</span>    <span class=comment>// end point vA.  
</span>    CVector3 vClosestPoint = vA + vVector3;

    <span class=comment>// Return the closest point on the line segment
</span>    <span class=keyword>return</span> vClosestPoint;
}

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>

<span class=comment>/////////////////////////////////////////////////////////////////////////////////
</span><span class=comment>//
</span><span class=comment>// * QUICK NOTES * 
</span><span class=comment>//
</span><span class=comment>// This is one of the more simple math tutorials to code, but it's incredibly
</span><span class=comment>// important to have when doing collision detection.  In the Sphere-Polygon collision
</span><span class=comment>// tutorial, we will use this technique to determine the collision on the edges.
</span><span class=comment>// 
</span><span class=comment>// Let me go over the basics of how we find the closest point on a line segment, to a
</span><span class=comment>// given point.
</span><span class=comment>// 
</span><span class=comment>// The dot product is the key function that makes all this magic work.  Basically,
</span><span class=comment>// if we get a vector between an end point of the line segment and the point, plus
</span><span class=comment>// a normalized directional vector of that end point to the other end point, we can
</span><span class=comment>// use the dot product to project the first vector onto the directional vector.  This
</span><span class=comment>// gives us a distance from the new project vector to the end point.  If that distance
</span><span class=comment>// is 0, the 2 vectors were perpendicular and the projected vector is directory on top
</span><span class=comment>// of the end point, which would make the distance 0.  If the distance is negative, the
</span><span class=comment>// point is on the outside of the line segment and closest to that end point.  If the
</span><span class=comment>// distance is positive; we know that the point is on the other side of the end point.
</span><span class=comment>// If we find the distance of the line segment, we can then check to see if the point
</span><span class=comment>// is closest to a point on the line, or it is past the other end point, which makes that
</span><span class=comment>// other end point the closest point to our given point.  To check the closest point
</span><span class=comment>// is inside the line and not an end point, we just make sure that the original dot product
</span><span class=comment>// result is less than the distance of the line segment. This distance can be calculated 
</span><span class=comment>// using the normal distance formula you use in algebra.  
</span><span class=comment>// 
</span><span class=comment>// So to sum it all up... if the distance &quot;t&quot; is less than 0, our first end point is the
</span><span class=comment>// closest point on the line, where if the distance &quot;t&quot; is greater than the distance of
</span><span class=comment>// the line, distance &quot;d&quot;, then it's the other end point.  If both of those fail, it must
</span><span class=comment>// be on the line between the 2 end points.  To calculate where, we multiply our directional
</span><span class=comment>// vector times the result of the dot product.  Then add that result to our original end point.
</span><span class=comment>// That will give us the closest point on the line, between the 2 end points.
</span><span class=comment>// 
</span><span class=comment>// Let us know at www.GameTutorials.com if this was helpful to you.  
</span><span class=comment>// Any feedback is welcome.
</span><span class=comment>// 
</span><span class=comment>// 
</span><span class=comment>// Ben Humphrey (DigiBen)
</span><span class=comment>// Game Programmer
</span><span class=comment>// DigiBen@GameTutorials.com
</span><span class=comment>// Co-Web Host of www.GameTutorials.com
</span><span class=comment>//
</span><span class=comment>//
</span></pre></body>
</html>
