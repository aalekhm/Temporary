<html>
<head>
<style>
.keyword{color:rgb(0,0,255);}
.comment{color:rgb(0,128,0);}
.pp{color:rgb(0,0,255);}
</style>
<body>
<pre style="font-family:courier;font-size:10pt">
<span class=pp>#include</span> &quot;main.h&quot;
<span class=pp>#include</span> &lt;math.h&gt;    <span class=comment>// We include math.h so we can use the sqrt() function
</span>
<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>
<span class=comment>// Because in our future tutorials we will be reusing all of this code quite often,
</span><span class=comment>// we will put it in a separate .cpp file.  Also this is nice because then we can
</span><span class=comment>// just copy 3DMath.cpp and 3DMath.h into a new project without having to cut and paste code.
</span><span class=comment>// Eventually, once this gets big enough you will probably want to make a library out of it.
</span>
<span class=comment>// *FINDING THE NORMAL OF A POLYGON*
</span>
<span class=comment>// In order to find the normal of a polygon, we need to take the cross product of 2
</span><span class=comment>// vectors from that polygon.  What that means, is that we need to get the directions
</span><span class=comment>// of 2 of the sides of our triangle.  After all, that is all a vector is, just a direction
</span><span class=comment>// and a length.  The length of our vectors in this case isn't really important.  We are
</span><span class=comment>// just going to use the direction.  Then, with those 2 vectors we can find a vector coming
</span><span class=comment>// straight out of the polygon, perpendicular (90 degrees) to the polygon.  To give you some
</span><span class=comment>// examples of a cross product of 2 vectors, let's assume that we have a piece of paper
</span><span class=comment>// lying flat on a table.  Where would the cross product of that paper be pointing?
</span><span class=comment>// Straight up!  But, the paper isn't a polygon really?  Well, all you are really getting
</span><span class=comment>// is the normal to a plane.  A plane is infinite, it goes on forever.  If you drew a triangle
</span><span class=comment>// in the middle of the piece of paper, the normal of that triangle would be the same as the paper,
</span><span class=comment>// so it doesn't matter does it?  That's why you are really getting a normal to the polygon's plane.
</span><span class=comment>// If you stuck the piece of paper straight up vertically, where would the normal be?  It would 
</span><span class=comment>// follow the paper perfectly as a 90 degree angle, so it would now we perfectly horizontal.  Now, 
</span><span class=comment>// depending on the order of your vertices, it could either being pointing out on one side of the paper, 
</span><span class=comment>// or on the other side.  You just have to decide which order you want to use, then ALWAYS stick
</span><span class=comment>// with that.  Usually, you want to do something called back face culling which doesn't
</span><span class=comment>// draw the back of a polygon.  That way you aren't drawing twice as much as you could be.
</span><span class=comment>// Think about it, it you have a huge 3D model, do you really need to draw the inside of
</span><span class=comment>// the model?  Of course not, that would be wasteful.  You always want to have your objects
</span><span class=comment>// enclosed so they don't show back of polygons.  Like in a 3D maze, you would just have
</span><span class=comment>// polygon thin walls, you would have thick walls which comprised of a cube like shape.
</span><span class=comment>// That way, when you get into BSP trees, you can do something called Solid Node BSP tree's.
</span>

<span class=comment>/////////////////////////////////////// CROSS \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span><span class=comment>/////
</span><span class=comment>/////    This returns a perpendicular vector from 2 given vectors by taking the cross product.
</span><span class=comment>/////
</span><span class=comment>/////////////////////////////////////// CROSS \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
</span>CVector3 cross(CVector3 vVector1, CVector3 vVector2) {
    
    CVector3 vNormal;        <span class=comment>// The vector to hold the cross product
</span>
    <span class=comment>// Once again, if we are given 2 vectors (directions of 2 sides of a polygon)
</span>    <span class=comment>// then we have a plane define.  The cross product finds a vector that is perpendicular
</span>    <span class=comment>// to that plane, which means it's point straight out of the plane at a 90 degree angle.
</span>    <span class=comment>// The equation for the cross product is simple, but difficult at first to memorize:
</span>    
    <span class=comment>// The X value for the vector is:  (V1.y * V2.z) - (V1.z * V2.y)                                                    // Get the X value
</span>    vNormal.x = ((vVector1.y * vVector2.z) - (vVector1.z * vVector2.y));

    <span class=comment>// The Y value for the vector is:  (V1.z * V2.x) - (V1.x * V2.z)
</span>    vNormal.y = ((vVector1.z * vVector2.x) - (vVector1.x * vVector2.z));
    
    <span class=comment>// The Z value for the vector is:  (V1.x * V2.y) - (V1.y * V2.x)
</span>    vNormal.z = ((vVector1.x * vVector2.y) - (vVector1.y * vVector2.x));

    <span class=comment>// *IMPORTANT* This is not communitive. You can not change the order or this or
</span>    <span class=comment>// else it won't work correctly.  It has to be exactly like that.  Just remember,
</span>    <span class=comment>// If you are trying to find the X, you don't use the X value of the 2 vectors, and
</span>    <span class=comment>// it's the same for the Y and Z.  You notice you use the other 2, but never that axis.
</span>    <span class=comment>// If you look at the camera rotation tutorial, you will notice it's the same for rotations.
</span>
    <span class=comment>// Now we have a vector pointing straight out of the plane of the polygon.  This is the
</span>    <span class=comment>// direction the polygon is facing.  You use this information for numerous things like
</span>    <span class=comment>// lighting, camera viewing, back face culling, collision and tons of other stuff.
</span>    
    <span class=keyword>return</span> vNormal;        <span class=comment>// Return the cross product (Direction the polygon is facing - Normal)
</span>}

<span class=comment>//This returns a vector between 2 points
</span>CVector3 makeVector(CVector3 vPoint1, CVector3 vPoint2) {
    
    CVector3 vVector = {0};        <span class=comment>// Initialize our variable to zero
</span>    
    <span class=comment>// In order to get a vector from 2 points (a direction) we need to
</span>    <span class=comment>// subtract the second point from the first point.
</span>    vVector.x = vPoint1.x - vPoint2.x;    <span class=comment>// Get the X value of our new vector
</span>    vVector.y = vPoint1.y - vPoint2.y;    <span class=comment>// Get the Y value of our new vector
</span>    vVector.z = vPoint1.z - vPoint2.z;    <span class=comment>// Get the Z value of our new vector
</span>    
    <span class=comment>// Now that we have our new vector between the 2 points, we will return it.
</span>    <span class=keyword>return</span> vVector;        <span class=comment>// Return our new vector
</span>}

<span class=comment>//This returns the magnitude of a normal (or any other vector)
</span><span class=keyword>float</span> magnitude(CVector3 vVector) {
    
    <span class=comment>// This will give us the magnitude or &quot;Norm&quot; as some say of, our normal.
</span>    <span class=comment>// The magnitude has to do with the length of the vector.  We use this
</span>    <span class=comment>// information to normalize a vector, which gives it a length of 1.
</span>    <span class=comment>// Here is the equation:  magnitude = sqrt(V.x^2 + V.y^2 + V.z^2)   Where V is the vector
</span>
    <span class=keyword>return</span> (<span class=keyword>float</span>)sqrt( (vVector.x * vVector.x) + (vVector.y * vVector.y) + (vVector.z * vVector.z) );
}

<span class=comment>//This returns a normalize vector (A vector exactly of length 1)
</span>CVector3 normalize(CVector3 vVector) {

    <span class=comment>// Get the magnitude of our normal
</span>    <span class=keyword>float</span> mag = magnitude(vVector);

    <span class=comment>// Now that we have the magnitude, we can divide our normal by that magnitude.
</span>    <span class=comment>// That will make our normal a total length of 1.  This makes it easier to work with too.
</span>
    vVector.x = vVector.x / mag;        <span class=comment>// Divide the X value of our vector by it's magnitude
</span>    vVector.y = vVector.y / mag;        <span class=comment>// Divide the Y value of our vector by it's magnitude
</span>    vVector.z = vVector.z / mag;        <span class=comment>// Divide the Z value of our vector by it's magnitude
</span>
    <span class=comment>// Finally, return our normalized vector.
</span>    <span class=keyword>return</span> vVector;                            <span class=comment>// Return the new normal of length 1.
</span>}

<span class=comment>//This returns the normal of a polygon (The direction the polygon is facing)
</span>CVector3 normal(CVector3 vTriangle[]) {

    <span class=comment>// You might want to error check to make sure it's valid
</span>    <span class=comment>// Get 2 vectors from the polygon
</span>
    CVector3 vVector1 = makeVector(vTriangle[2], vTriangle[0]);
    CVector3 vVector2 = makeVector(vTriangle[1], vTriangle[0]);

    <span class=comment>// We Chose to get the vectors surrounding the first point of the polygon.
</span>    <span class=comment>// We could have chosen to get 2 other sides of the triangle, but we chose these 2.
</span>    <span class=comment>// Now that we have the 2 side vectors, we will take their cross product.
</span>    <span class=comment>// (*NOTE*) It is important that pass in the vector of the bottom side of the triangle
</span>    <span class=comment>// first, and then pass in the vector of the left side second.  If we switch them,
</span>    <span class=comment>// it will turn the normal the opposite way.  Try it, switch them like this: Cross(vVector2, vVector1);
</span>    <span class=comment>// Like I said before, it's important to ALWAYS work in the same direction.  In our case,
</span>    <span class=comment>// we chose that we always work counter-clockwise.
</span>
    CVector3 vNormal = cross(vVector1, vVector2);

    <span class=comment>// Now that we have the direction of the normal, we want to do one last thing.
</span>    <span class=comment>// Right now, it's an unknown length, it is probably pretty long in length.
</span>    <span class=comment>// We want to do something which gives the normal a length of 1.  This is called
</span>    <span class=comment>// normalizing.  To do this we divide the normal by it's magnitude.  Well how do we
</span>    <span class=comment>// find it's magnitude? We use this equation: magnitude = sqrt(x^2 + y^2 + z^2)
</span>    
    vNormal = normalize(vNormal);        <span class=comment>// Use our function we created to normalize the normal (Makes it a length of one)
</span>
    <span class=comment>// Now return the normalized normal
</span>    <span class=comment>// (*NOTE*) If you want to understand what normalizing our normal does, comment out
</span>    <span class=comment>// the above line.  Then you can see how long the normal is before we normalize it.
</span>    <span class=comment>// I strongly recommend this.  And remember, it doesn't matter how long the normal is,
</span>    <span class=comment>// (of course besides (0, 0, 0)), if we normalize it, it will always be of length 1 afterwards.
</span>
    <span class=keyword>return</span> vNormal;                        <span class=comment>// Return our normal at our desired length
</span>}

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>
<span class=comment>/////////////////////////////////////////////////////////////////////////////////
</span><span class=comment>//
</span><span class=comment>// * QUICK NOTES * 
</span><span class=comment>//
</span><span class=comment>// That how you find the normal to a polygon.  Pretty complicated huh? :)
</span><span class=comment>// well, the good thing about this is that once you code, you never have to do it
</span><span class=comment>// again.  There is no need, once you already have the functions.  Eventually you
</span><span class=comment>// will build up a big library of math.  As we start getting into collision you will
</span><span class=comment>// see what I mean.  That is why we separated the math into a separate file, because
</span><span class=comment>// you will use the same code over and over in your applications.  I know I do.
</span><span class=comment>// I feel naked with out my gamemath.cpp :)
</span><span class=comment>// 
</span><span class=comment>// Basically, let me explain the steps again to finding the normal of a polygon.
</span><span class=comment>// 
</span><span class=comment>// 1)  First, if you have 3 points of a polygon, you can find a normal to that plane.
</span><span class=comment>//     The first step you need to do is get 2 vectors from that polygon.  That means
</span><span class=comment>//     that you need to pick to sides of the triangle (order is important) and subtract
</span><span class=comment>//     the points from each other to get the vector of that side.  When it comes to triangles,
</span><span class=comment>//     I usually get the first vector from Point3 - Point1. (V1 = P3 - P1)
</span><span class=comment>//     Next, I choose Vector 2 from Point2 and Point1 (V2 = P2 - P1).  
</span><span class=comment>//
</span><span class=comment>// 2)  Now that we have 2 vectors:  V1 and V2, we can take the cross product of those 
</span><span class=comment>//     2 vectors, with vector1 cross vector2.  Remember, the order is important.  
</span><span class=comment>//     I always go counter-clockwise.  Pick and stick!  This is important because it decides the
</span><span class=comment>//     direction of the normal.  It doesn't matter which direction, as long as you do the same
</span><span class=comment>//     thing for all the rest of your polygons.  You don't want mixed up normal directions.
</span><span class=comment>// 
</span><span class=comment>// 3)  Now we should have the normal (Or direction) from the cross product of our polygon.
</span><span class=comment>//     This normal has a strange length, so let's make the length (or distance from the origin) 1.
</span><span class=comment>//     To do this, we take the magnitude (Deals with the length of the vector) of the normal.
</span><span class=comment>//     With the magnitude, we divide the normal BY that magnitude.  That means the X, Y and Z values
</span><span class=comment>//     get divided by the magnitude scalar.  A scalar is a single number like 1, 1.232, etc...
</span><span class=comment>// 
</span><span class=comment>// That's it!  Three basic steps to finding the normal.  It is nice not to have to worry about
</span><span class=comment>// all that once you have a function that does it all for you.  We call ours &quot;Normal()&quot;.  It
</span><span class=comment>// won't matter it we have a polygon of 20 vertices, all we need is just 3 points (the first 3)
</span><span class=comment>// from that polygon.  That is enough to define a plane.  Then we find the normal to that plane.
</span><span class=comment>//
</span><span class=comment>// 
</span><span class=comment>// I hope this help!  Let us know at www.GameTutorials.com if this helped you at all.
</span><span class=comment>//
</span><span class=comment>// Good luck, and get ready for the collision tutorial next!
</span><span class=comment>//
</span><span class=comment>//
</span><span class=comment>// Ben Humphrey (DigiBen)
</span><span class=comment>// Game Programmer
</span><span class=comment>// DigiBen@GameTutorials.com
</span><span class=comment>// Co-Web Host of www.GameTutorials.com
</span><span class=comment>//
</span></pre></body>
</html>
