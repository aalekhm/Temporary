<html>
<head>
<style>
.keyword{color:rgb(0,0,255);}
.comment{color:rgb(0,128,0);}
.pp{color:rgb(0,0,255);}
</style>
<body>
<pre style="font-family:courier;font-size:10pt">
<span class=pp>#include</span> &quot;CCamera.h&quot;

<span class=keyword>void</span> CCamera::setPosition(CVector3 position) {
    cameraPosition = position;
}

<span class=keyword>void</span> CCamera::rotateX(<span class=keyword>float</span> angle) {
    <span class=comment>//Rotate viewdir around the right vector:
</span>    viewVector = normalize(    viewVector*cos(angle * piOver180)
                            + 
                            upVector*sin(angle * piOver180)
                        );

    <span class=pp>#if</span> CAMERA_TYPE == CAMERA_AIRCRAFT
        <span class=comment>//now compute the new UpVector (by cross product)
</span>        upVector = cross(viewVector, rightVector)*-1;
    <span class=pp>#endif</span>
}

<span class=keyword>void</span> CCamera::rotateY(<span class=keyword>float</span> angle) {
    <span class=comment>//Rotate viewdir around the right vector:
</span>    viewVector = normalize(    viewVector*cos(angle * piOver180)
                            -
                            rightVector*sin(angle * piOver180)
                        );

    <span class=comment>//now compute the new UpVector (by cross product)
</span>    rightVector = cross(viewVector, upVector);
}

<span class=keyword>void</span> CCamera::rotateZ(<span class=keyword>float</span> angle) {
    <span class=comment>//Rotate viewdir around the right vector:
</span>    rightVector = normalize(    rightVector*cos(angle * piOver180)
                                +
                                upVector*sin(angle * piOver180)
                            );

    <span class=pp>#if</span> CAMERA_TYPE == CAMERA_AIRCRAFT
        <span class=comment>//now compute the new UpVector (by cross product)
</span>        upVector = cross(viewVector, rightVector)*-1;
    <span class=pp>#endif</span>
}

<span class=keyword>void</span> CCamera::moveForward(<span class=keyword>float</span> distance) {
    cameraPosition = cameraPosition + (viewVector*distance);
}

<span class=keyword>void</span> CCamera::strafeRight(<span class=keyword>float</span> distance) {
    cameraPosition = cameraPosition + (rightVector*distance);
}

<span class=keyword>void</span> CCamera::moveUpward(<span class=keyword>float</span> distance) {
    cameraPosition = cameraPosition + (upVector*distance);
}

<span class=comment>/*PITCH - Rotation around X - axis */</span>
<span class=keyword>void</span> CCamera::cameraPitch(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 1.0f, 0.0f, 0.0f);
}

<span class=comment>/*YAW - Rotation around Y - axis */</span>
<span class=keyword>void</span> CCamera::cameraYaw(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 0.0f, 1.0f, 0.0f);
}

<span class=comment>/*ROLL - Rotation around Z - axis */</span>
<span class=keyword>void</span> CCamera::cameraRoll(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 0.0f, 0.0f, 1.0f);
}

<span class=keyword>void</span> CCamera::cameraMoveTo(CVector3 camPos) {
    glTranslatef(-camPos.x, -camPos.y <span class=comment>/*+ CROUCH*0.25f*/</span>, -camPos.z);
}

<span class=keyword>void</span> CCamera::checkMouseMovementForGLULookAt() {
    <span class=keyword>int</span> screenCenterX = SCREEN_WIDTH&gt;&gt;1;
    <span class=keyword>int</span> screenCenterY = SCREEN_HEIGHT&gt;&gt;1;

    POINT mousePos;
    GetCursorPos(&amp;mousePos);
    
    <span class=comment>//Mouse not moved, hence return;
</span>    <span class=keyword>if</span>(mousePos.x == screenCenterX &amp;&amp; mousePos.y == screenCenterY)
        <span class=keyword>return</span>;

    SetCursorPos(screenCenterX, screenCenterY);
    
    <span class=comment>//Move, Rotate as proportinal to the displacement
</span>    <span class=keyword>float</span> deltaX = (mousePos.x - screenCenterX)/5.0f;
    <span class=keyword>float</span> deltaY = (mousePos.y - screenCenterY)/5.0f;
    <span class=comment>///*
</span>    <span class=keyword>bool</span> yesRotateX = <span class=keyword>false</span>;
    <span class=keyword>if</span>(deltaY &lt;= 0) {
        <span class=keyword>if</span>(cameraRotation.x &lt; 80) {
            yesRotateX = <span class=keyword>true</span>;
        }
    }
    <span class=keyword>else</span> 
    <span class=keyword>if</span>(deltaY &gt; 0) {
        <span class=keyword>if</span>(cameraRotation.x &gt; -80) {
            yesRotateX = <span class=keyword>true</span>;
        }
    }
    <span class=comment>//*/
</span>    <span class=keyword>if</span>(yesRotateX) {
        cameraRotation.x -= deltaY;
        rotateX(-deltaY);
    }

    cameraRotation.y -= deltaX;
    rotateY(-deltaX);
}

<span class=keyword>void</span> CCamera::checkMouseMovementForTranslatef() {
    <span class=keyword>int</span> screenCenterX = SCREEN_WIDTH&gt;&gt;1;
    <span class=keyword>int</span> screenCenterY = SCREEN_HEIGHT&gt;&gt;1;

    POINT mousePos;
    GetCursorPos(&amp;mousePos);
    
    <span class=comment>//Mouse not moved, hence return;
</span>    <span class=keyword>if</span>(mousePos.x == screenCenterX &amp;&amp; mousePos.y == screenCenterY)
        <span class=keyword>return</span>;

    SetCursorPos(screenCenterX, screenCenterY);
    
    <span class=comment>//Move, Rotate as proportinal to the displacement
</span>    <span class=keyword>float</span> deltaX = (mousePos.x - screenCenterX)/5.0f;
    <span class=keyword>float</span> deltaY = (mousePos.y - screenCenterY)/5.0f;

    cameraRotation.x -= deltaY;
    cameraRotation.y -= deltaX;
}

<span class=keyword>void</span> CCamera::checkKeyboardMovementForGLULookAt() {
    <span class=keyword>bool</span> isWalking = <span class=keyword>false</span>;
    <span class=keyword>if</span>(mKeys[VK_UP]) {
        <span class=keyword>if</span>(cameraRotation.x &lt; 80) {
            cameraRotation.x = ((<span class=keyword>int</span>)cameraRotation.x + 1) % 360;
            rotateX(1.0);
        }
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys[VK_DOWN]) {
        <span class=keyword>if</span>(cameraRotation.x &gt; -80) {
            cameraRotation.x = ((<span class=keyword>int</span>)cameraRotation.x - 1) % 360;
            rotateX(-1.0);
        }
    }
    
    <span class=keyword>if</span>(mKeys['Q'] || mKeys[VK_LEFT]) {
        cameraRotation.y = ((<span class=keyword>int</span>)cameraRotation.y + 1) % 360;
        rotateY(1.0);
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['E'] || mKeys[VK_RIGHT]) {
        cameraRotation.y = ((<span class=keyword>int</span>)cameraRotation.y - 1) % 360;
        rotateY(-1.0);
    }

    <span class=pp>#if</span> CAMERA_TYPE == CAMERA_AIRCRAFT
        <span class=keyword>if</span>(mKeys['Z']) {
            cameraRotation.z = ((<span class=keyword>int</span>)cameraRotation.z + 1) % 360;
            rotateZ(-1.0);
        }
        <span class=keyword>if</span>(mKeys['X']) {
            cameraRotation.z = ((<span class=keyword>int</span>)cameraRotation.z - 1) % 360;
            rotateZ(1.0);
        }
    <span class=pp>#endif</span>

    <span class=keyword>if</span>(mKeys['W'] || L_MOUSE_DOWN) {
        moveForward(WALK_SPEED + L_MOUSE_DOWN*WALK_SPEED);
        isWalking = <span class=keyword>true</span>;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['S'] || R_MOUSE_DOWN) {
        moveForward(-(WALK_SPEED + R_MOUSE_DOWN*WALK_SPEED));
        isWalking = <span class=keyword>true</span>;
    }
    
    <span class=keyword>if</span>(mKeys['A']) {
        strafeRight(-WALK_SPEED);
        isWalking = <span class=keyword>true</span>;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['D']) {
        strafeRight(WALK_SPEED);
        isWalking = <span class=keyword>true</span>;
    }
    
    <span class=keyword>if</span>(mKeys[VK_PRIOR]) {
        moveUpward(WALK_SPEED);
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys[VK_NEXT]) {
        moveUpward(-WALK_SPEED);
    }

    <span class=keyword>if</span>(isWalking)
        PLAYER_STATE = PLAYER_WALK;
}

<span class=keyword>void</span> CCamera::checkKeyboardMovementForTranslatef() {
    <span class=keyword>bool</span> isWalking = <span class=keyword>false</span>;
    
    <span class=keyword>float</span> sinTheta = sin( cameraRotation.y * piOver180 );
    <span class=keyword>float</span> cosTheta = cos( cameraRotation.y * piOver180 );
    <span class=keyword>float</span> SPEED = (WALK_SPEED + L_MOUSE_DOWN*WALK_SPEED);

    <span class=keyword>if</span>(mKeys['Q'] || mKeys[VK_LEFT]) {
        cameraRotation.y = ((<span class=keyword>int</span>)cameraRotation.y + 1) % 360;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['E'] || mKeys[VK_RIGHT]) {
        cameraRotation.y = ((<span class=keyword>int</span>)cameraRotation.y - 1) % 360;
    }
    
    <span class=keyword>if</span>(mKeys['W'] || L_MOUSE_DOWN) {
        cameraPosition.x -= sinTheta * SPEED;
        cameraPosition.z -= cosTheta * SPEED;
        isWalking = <span class=keyword>true</span>;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['S'] || R_MOUSE_DOWN) {
        cameraPosition.x += sinTheta * SPEED;
        cameraPosition.z += cosTheta * SPEED;
        isWalking = <span class=keyword>true</span>;
    }
    
    <span class=keyword>if</span>(mKeys['A']) {
        cameraPosition.x += -cosTheta * SPEED;
        cameraPosition.z +=  sinTheta * SPEED;
        isWalking = <span class=keyword>true</span>;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys['D']) {
        cameraPosition.x -= -cosTheta * SPEED;
        cameraPosition.z -=  sinTheta * SPEED;
        isWalking = <span class=keyword>true</span>;
    }
    
    <span class=keyword>if</span>(mKeys[VK_UP]) {
        cameraRotation.x = ((<span class=keyword>int</span>)cameraRotation.x + 1) % 360;
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys[VK_DOWN]) {
        cameraRotation.x = ((<span class=keyword>int</span>)cameraRotation.x - 1) % 360;
    }
    
    <span class=keyword>if</span>(mKeys[VK_PRIOR]) {
        moveUpward(WALK_SPEED);
    }
    <span class=keyword>else</span>
    <span class=keyword>if</span>(mKeys[VK_NEXT]) {
        moveUpward(-WALK_SPEED);
    }


    <span class=keyword>if</span>(isWalking)
        PLAYER_STATE = PLAYER_WALK;
}

<span class=keyword>void</span> CCamera::updateCamera(<span class=keyword>void</span>) {
    <span class=keyword>if</span>(CAMERA_HAS_GRAVITY) {
            <span class=comment>//Constant free fall
</span>            <span class=keyword>float</span> G = -GRAVITY;
            <span class=keyword>float</span> Y = G;
            <span class=keyword>if</span>(TRAMP &gt; 0) {
                TRAMP += -GRAVITY;
                Y = TRAMP;
            }
            <span class=keyword>else</span>
                TRAMP = 0;
            cameraPosition.y += Y;
    }
    
    <span class=keyword>if</span>(mKeys['G']) {
        <span class=keyword>if</span>(!mKeysPressed['G']) {
            mKeysPressed['G'] = <span class=keyword>true</span>;
            CAMERA_HAS_GRAVITY = !CAMERA_HAS_GRAVITY;
        }
    }
    <span class=keyword>else</span>
        mKeysPressed['G'] = <span class=keyword>false</span>;


    <span class=keyword>if</span>(mKeys['C']) {
        <span class=keyword>if</span>(!mKeysPressed['C']) {
            mKeysPressed['C'] = <span class=keyword>true</span>;

            cameraHasCollisions = !cameraHasCollisions;
        }
    }
    <span class=keyword>else</span>
        mKeysPressed['C'] = <span class=keyword>false</span>;

    <span class=keyword>if</span>(mKeys['I']) {
        <span class=keyword>if</span>(!mKeysPressed['I']) {
            mKeysPressed['I'] = <span class=keyword>true</span>;
            CAMERA_IMPLEMENT_TYPE = (CAMERA_IMPLEMENT_TYPE == CAMERA_GLULOOKAT)?CAMERA_TRANSLATE:CAMERA_GLULOOKAT;
        }
    }
    <span class=keyword>else</span> 
        mKeysPressed['I'] = <span class=keyword>false</span>;


    <span class=keyword>if</span>(CAMERA_IMPLEMENT_TYPE == CAMERA_GLULOOKAT) {
        checkKeyboardMovementForGLULookAt();
        checkMouseMovementForGLULookAt();
    }
    <span class=keyword>else</span> {
        checkKeyboardMovementForTranslatef();
        checkMouseMovementForTranslatef();
    }
}

<span class=keyword>void</span> CCamera::moveCamera(<span class=keyword>void</span>) {
    
    <span class=keyword>if</span>(CAMERA_IMPLEMENT_TYPE == CAMERA_GLULOOKAT) {
            CVector3 viewPoint = cameraPosition + viewVector;
            gluLookAt(    cameraPosition.x,    cameraPosition.y,    cameraPosition.z,
                        viewPoint.x,        viewPoint.y,        viewPoint.z,
                        upVector.x,            upVector.y,            upVector.z
                    );
    }
    <span class=keyword>else</span> 
    <span class=keyword>if</span>(CAMERA_IMPLEMENT_TYPE == CAMERA_TRANSLATE) {
        <span class=comment>//Player Camera - Rotation
</span>        cameraPitch(-cameraRotation.x);
        cameraYaw(-cameraRotation.y);
        cameraRoll(-cameraRotation.z);
        
        <span class=comment>//Player Camera - Translation
</span>        cameraMoveTo(cameraPosition);
    }
}

<span class=keyword>void</span> CCamera::cameraDebug() {
    glPrint(SCREEN_WIDTH - 300, SCREEN_HEIGHT - 10, &quot;'G' GRAVITY - 'G' == %d&quot;, CAMERA_HAS_GRAVITY);
    glPrint(SCREEN_WIDTH - 300, SCREEN_HEIGHT - 20, &quot;'C' CAMERA COLLISIONS == %d&quot;, cameraHasCollisions);
    glPrint(SCREEN_WIDTH - 300, SCREEN_HEIGHT - 30, &quot;'I' CAMERA TYPE = %s&quot;,(CAMERA_IMPLEMENT_TYPE == CAMERA_GLULOOKAT)?&quot;CAMERA_GLULOOKAT&quot;:&quot;CAMERA_TRANSLATE&quot;);

    glPrint(SCREEN_WIDTH - 300, 40, &quot;DEBUG : %s&quot;, debugString);
    glPrint(SCREEN_WIDTH - 300, 30, &quot;CAM POS : %0.2f %0.2f %0.2f&quot;, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    glPrint(SCREEN_WIDTH - 300, 20, &quot;CAM ROT : %0.2f %0.2f %0.2f&quot;, cameraRotation.x, cameraRotation.y, cameraRotation.z);
    glPrint(SCREEN_WIDTH - 300, 10, &quot;VIEW VECT : %0.2f %0.2f %0.2f&quot;, viewVector.x, viewVector.y, viewVector.z);
}

<span class=keyword>void</span> CCamera::setGravity(<span class=keyword>bool</span> bHasGravity) {
    CAMERA_HAS_GRAVITY = bHasGravity;
}

<span class=comment>//void CCamera::setCollision(bool bHasCollision) {
</span><span class=comment>//    CAMERA_HAS_COLLISIONS = bHasCollision;
</span><span class=comment>//}
</span>
<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span><span class=comment>//This checks all the polygons in our list and offsets the camera if collided
</span><span class=keyword>void</span> CCamera::checkCameraCollision(SCENE* scene) {


    <span class=comment>// This function is pretty much a direct rip off of SpherePolygonCollision()
</span>    <span class=comment>// We needed to tweak it a bit though, to handle the collision detection once 
</span>    <span class=comment>// it was found, along with checking every triangle in the list if we collided.  
</span>    <span class=comment>// pVertices is the world data. If we have space partitioning, we would pass in 
</span>    <span class=comment>// the vertices that were closest to the camera. What happens in this function 
</span>    <span class=comment>// is that we go through every triangle in the list and check if the camera's 
</span>    <span class=comment>// sphere collided with it.  If it did, we don't stop there.  We can have 
</span>    <span class=comment>// multiple collisions so it's important to check them all.  One a collision 
</span>    <span class=comment>// is found, we calculate the offset to move the sphere off of the collided plane.
</span>    
    CVector3 LEG_POS = cameraPosition;    <span class=comment>//Camera is our eyes
</span>    LEG_POS.y -= 0.15f;                    <span class=comment>//so go to the Legs, the invisible collision sphere is at the legs
</span>
    <span class=comment>// Go through all the triangles
</span>    <span class=keyword>for</span>(<span class=keyword>int</span> i = 0; i &lt; scene-&gt;maxFaces; i++) {
        <span class=keyword>int</span> vertex0 = scene-&gt;faces[i].vertexID[0] - 1;
        <span class=keyword>int</span> vertex1 = scene-&gt;faces[i].vertexID[1] - 1;
        <span class=keyword>int</span> vertex2 = scene-&gt;faces[i].vertexID[2] - 1;
        <span class=keyword>int</span> vertex3 = scene-&gt;faces[i].vertexID[3] - 1;
        
        CVector3 vVertex0 = CVector3(scene-&gt;vertices[vertex0].x, scene-&gt;vertices[vertex0].y, scene-&gt;vertices[vertex0].z);
        CVector3 vVertex1 = CVector3(scene-&gt;vertices[vertex1].x, scene-&gt;vertices[vertex1].y, scene-&gt;vertices[vertex1].z);
        CVector3 vVertex2 = CVector3(scene-&gt;vertices[vertex2].x, scene-&gt;vertices[vertex2].y, scene-&gt;vertices[vertex2].z);
        CVector3 vVertex3 = CVector3(scene-&gt;vertices[vertex3].x, scene-&gt;vertices[vertex3].y, scene-&gt;vertices[vertex3].z);

        <span class=comment>// Store of the current triangle we testing
</span>        CVector3 vPolygon[4] = {vVertex3, vVertex2, vVertex1, vVertex0};<span class=comment>//Give in clockwise direction
</span>
        <span class=comment>// 1) STEP ONE - Finding the sphere's classification
</span>    
        <span class=comment>// We want the normal to the current polygon being checked
</span>        CVector3 vNormal = normal(vPolygon);

        <span class=comment>// This will store the distance our sphere is from the plane
</span>        <span class=keyword>float</span> distance = 0.0f;

        <span class=comment>// This is where we determine if the sphere is in FRONT, BEHIND, or INTERSECTS the plane
</span>        <span class=keyword>int</span> classification = classifySphere(LEG_POS, vNormal, vPolygon[0], camRadius, distance);
<span class=keyword>char</span> logText[255] = {0};
sprintf(debugString, &quot;class = %d %0.2f %0.2f %0.2f &quot;, classification, vNormal.x, vNormal.y, vNormal.z);
<span class=comment>//MessageBox(NULL, logText, &quot;logText&quot;, MB_OK);
</span>
        <span class=comment>// If the sphere intersects the polygon's plane, then we need to check further
</span>        <span class=keyword>if</span>(classification == INTERSECTS) {
            <span class=comment>// 2) STEP TWO - Finding the psuedo intersection point on the plane
</span>
            <span class=comment>// Now we want to project the sphere's center onto the triangle's plane
</span>            CVector3 vOffset = vNormal * distance;

            <span class=comment>// Once we have the offset to the plane, we just subtract it from the center
</span>            <span class=comment>// of the sphere.  &quot;vIntersection&quot; is now a point that lies on the plane of the triangle.
</span>            CVector3 vIntersection = LEG_POS - vOffset;

            <span class=comment>// 3) STEP THREE - Check if the intersection point is inside the triangles perimeter
</span>
            <span class=comment>// We first check if our intersection point is inside the triangle, if not,
</span>            <span class=comment>// the algorithm goes to step 4 where we check the sphere again the polygon's edges.
</span>
            <span class=comment>// We do one thing different in the parameters for EdgeSphereCollision though.
</span>            <span class=comment>// Since we have a bulky sphere for our camera, it makes it so that we have to 
</span>            <span class=comment>// go an extra distance to pass around a corner. This is because the edges of 
</span>            <span class=comment>// the polygons are colliding with our peripheral view (the sides of the sphere).  
</span>            <span class=comment>// So it looks likes we should be able to go forward, but we are stuck and considered 
</span>            <span class=comment>// to be colliding.  To fix this, we just pass in the radius / 2.  Remember, this
</span>            <span class=comment>// is only for the check of the polygon's edges.  It just makes it look a bit more
</span>            <span class=comment>// realistic when colliding around corners.  Ideally, if we were using bounding box 
</span>            <span class=comment>// collision, cylinder or ellipses, this wouldn't really be a problem.
</span>
            <span class=keyword>if</span>(    insidePolygon(vIntersection, vPolygon, 4) 
                ||
                edgeSphereCollision(LEG_POS, vPolygon, 4, camRadius / 2)
            ) {

                <span class=comment>// If we get here, we have collided!  To handle the collision detection
</span>                <span class=comment>// all it takes is to find how far we need to push the sphere back.
</span>                <span class=comment>// GetCollisionOffset() returns us that offset according to the normal,
</span>                <span class=comment>// radius, and current distance the center of the sphere is from the plane.
</span>                vOffset = getCollisionOffset(vNormal, camRadius, distance);
<span class=comment>//sprintf(debugString, &quot;vNormal = %0.2f %0.2f %0.2f &quot;, vNormal.x, vNormal.y, vNormal.z);
</span>                <span class=comment>// Now that we have the offset, we want to ADD it to the position and
</span>                <span class=comment>// view vector in our camera.  This pushes us back off of the plane.  We
</span>                <span class=comment>// don't see this happening because we check collision before we render
</span>                <span class=comment>// the scene.
</span>                cameraPosition = cameraPosition + vOffset;

            }
        }
    }
}
</pre></body>
</html>
