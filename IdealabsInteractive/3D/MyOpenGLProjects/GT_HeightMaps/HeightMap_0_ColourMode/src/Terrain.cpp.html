<html>
<head>
<style>
.keyword{color:rgb(0,0,255);}
.comment{color:rgb(0,128,0);}
.pp{color:rgb(0,0,255);}
</style>
<body>
<pre style="font-family:courier;font-size:10pt">
<span class=pp>#include</span> &quot;main.h&quot;

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span>
<span class=comment>// This file handles all of the terrain functions.  
</span><span class=comment>//
</span><span class=comment>// * NOTE * 
</span><span class=comment>//
</span><span class=comment>// The terrain might look small on the screen, and considering how fast we
</span><span class=comment>// move about it, but it's actually quite huge and could be a whole world 
</span><span class=comment>// to walk around.  So don't be fooled :)
</span><span class=comment>//
</span><span class=comment>//
</span><span class=comment>//
</span>
<span class=comment>// This loads a .raw file into an array of bytes.  Each value is a height value.
</span><span class=keyword>void</span> loadRawHeightMap(LPSTR strName, <span class=keyword>int</span> nSize, BYTE* pHeightMap) {
    
    FILE* pFile = NULL;

    <span class=comment>// Let's open the file in Read/Binary mode.
</span>    pFile = fopen(strName, &quot;rb&quot;);

    <span class=comment>// Check to see if we found the file and could open it
</span>    <span class=keyword>if</span>(pFile == NULL) {
        
        <span class=comment>// Display our error message and stop the function
</span>        MessageBox(NULL, &quot;Can't find Height Map!&quot;, &quot;Error&quot;, MB_OK);
        <span class=keyword>return</span>;
    }

    <span class=comment>// Here we load the .raw file into our pHeightMap data array.
</span>    <span class=comment>// We are only reading in '1', and the size is the (width * height)
</span>    fread(pHeightMap, 1, nSize, pFile);

    <span class=comment>// After we read the data, it's a good idea to check if everything read fine.
</span>    <span class=keyword>int</span> hasError = ferror(pFile);

    <span class=comment>// Check if we received an error.
</span>    <span class=keyword>if</span>(hasError) {
        MessageBox(NULL, &quot;Can't get Data!&quot;, &quot;Error&quot;, MB_OK);
    }
    
    <span class=comment>// Close the file.
</span>    fclose(pFile);
}

<span class=comment>// This returns the height (0 to 255) from a heightmap given an X and Y
</span><span class=keyword>int</span> getHeight(BYTE* pHeightMap, <span class=keyword>int</span> X, <span class=keyword>int</span> Y) {
    
    <span class=comment>// This is used to index into our height map array.
</span>    <span class=comment>// When ever we are dealing with arrays, we want to make sure
</span>    <span class=comment>// that we don't go outside of them, so we make sure that doesn't
</span>    <span class=comment>// happen with a %.  This way x and y will cap out at (MAX_SIZE - 1)
</span>
    <span class=keyword>int</span> x = X % MAP_SIZE;        <span class=comment>// Error check our x value
</span>    <span class=keyword>int</span> y = Y % MAP_SIZE;        <span class=comment>// Error check our y value
</span>
    <span class=keyword>if</span>(!pHeightMap)                <span class=comment>// Make sure our data is valid
</span>        <span class=keyword>return</span> 0;

    <span class=comment>// Below, we need to treat the single array like a 2D array.
</span>    <span class=comment>// We can use the equation: index = (x + (y * arrayWidth) ).
</span>    <span class=comment>// This is assuming we are using this assumption array[x][y]
</span>    <span class=comment>// otherwise it's the opposite.  Now that we have the correct index,
</span>    <span class=comment>// we will return the height in that index.
</span>
    <span class=keyword>return</span> pHeightMap[x + (y*MAP_SIZE)];    <span class=comment>// Index into our height array and return the height
</span>}

<span class=comment>// This sets the color value for a particular index, depending on the height index
</span><span class=keyword>void</span> setVertexColour(BYTE* pHeightMap, <span class=keyword>int</span> X, <span class=keyword>int</span> Y) {
    
    <span class=keyword>if</span>(!pHeightMap)                    <span class=comment>// Make sure our height data is valid
</span>        <span class=keyword>return</span>;

    <span class=comment>// Here we set the color for a vertex based on the height index.
</span>    <span class=comment>// To make it darker, I start with -0.15f.  We also get a ratio
</span>    <span class=comment>// of the color from 0 to 1.0 by dividing the height by 256.0f;
</span>    <span class=keyword>float</span> fColour = -0.15f + (getHeight(pHeightMap, X, Y) / 256.0f);

    <span class=comment>// Assign this green shade to the current vertex
</span>    glColor3f(0, fColour, 0);
}

<span class=comment>// This turns heightmap data into primitives and draws them to the screen
</span><span class=comment>// This renders the height map as QUADS
</span><span class=keyword>void</span> renderHeightMap(BYTE* pHeightMap) {

    <span class=keyword>int</span> X = 0, Y = 0;                    <span class=comment>// Create some variables to walk the array with.
</span>    <span class=keyword>int</span> x, y, z;                        <span class=comment>// Create some variables for readability
</span>    <span class=keyword>float</span> colour = 0.0f;                <span class=comment>// Create a variable to hold our color of the polygon
</span>
    <span class=keyword>if</span>(!pHeightMap)                        <span class=comment>// Make sure our height data is valid
</span>        <span class=keyword>return</span>;
    
    glBegin(GL_QUADS);                    <span class=comment>// Render Quads
</span>
        <span class=comment>// Next we actually need to draw the terrain from the height map.
</span>        <span class=comment>// To do that, we just walk the array of height data and pluck out
</span>        <span class=comment>// some heights to plot our points.  If we could see this happening,
</span>        <span class=comment>// it would draw the columns first (Y), then draw the rows.
</span>        <span class=comment>// Notice that we have a STEP_SIZE.  This determines how defined our
</span>        <span class=comment>// height map is.  The higher the STEP_SIZE, the more blocky the terrain
</span>        <span class=comment>// looks, while the lower it gets, the more rounded it becomes.
</span>        <span class=comment>// If we set STEP_SIZE = 1 it would create a vertex for every pixel in the height map.
</span>        <span class=comment>// I chose 16 as a decent size.  Anything too much less gets to be insane and slow.
</span>        <span class=comment>// Of course, you can increase the number when you get lighting in.
</span>        <span class=comment>// Then vertex lighting would cover up the blocky shape.  Instead of lighting,
</span>        <span class=comment>// we just put a color value associated with every poly to simplify the tutorial.
</span>        <span class=comment>// The higher the polygon, the brighter the color is.
</span>    <span class=keyword>char</span> logText[255] = {0};
        <span class=keyword>for</span>(X = 0; X &lt; MAP_SIZE; X += STEP_SIZE) {
            <span class=keyword>for</span>(Y = 0; Y &lt; MAP_SIZE; Y += STEP_SIZE) {

                <span class=comment>// Get the (X, Y, Z) value for the top left vertex        
</span>                x = X;
                y = getHeight(pHeightMap, X, Y );    
                z = Y;
                <span class=comment>// Set the color value of the current vertice
</span>                setVertexColour(pHeightMap, x, z);
<span class=keyword>if</span>(X == 0 &amp;&amp; Y == 0)
    glColor3ub(255, 255, 0);
                glVertex3i(x, y, z);            <span class=comment>// Send this vertex to OpenGL to be rendered (integer points are faster)
</span>
                <span class=comment>// Get the (X, Y, Z) value for the bottom left vertex        
</span>                x = X;
                y = getHeight(pHeightMap, X, Y + STEP_SIZE );  
                z = Y + STEP_SIZE ;
                <span class=comment>// Set the color value of the current vertex
</span>                setVertexColour(pHeightMap, x, z);
<span class=keyword>if</span>(X == 0 &amp;&amp; Y == STEP_SIZE)
    glColor3ub(255, 0, 0);
                glVertex3i(x, y, z);            <span class=comment>// Send this vertex to OpenGL to be rendered
</span>
                <span class=comment>// Get the (X, Y, Z) value for the bottom right vertex        
</span>                x = X + STEP_SIZE; 
                y = getHeight(pHeightMap, X + STEP_SIZE, Y + STEP_SIZE ); 
                z = Y + STEP_SIZE ;
                <span class=comment>// Set the color value of the current vertex
</span>                setVertexColour(pHeightMap, x, z);
<span class=keyword>if</span>(X == STEP_SIZE &amp;&amp; Y == STEP_SIZE)
    glColor3ub(255, 0, 255);
                glVertex3i(x, y, z);            <span class=comment>// Send this vertex to OpenGL to be rendered
</span>
                <span class=comment>// Get the (X, Y, Z) value for the top right vertex        
</span>                x = X + STEP_SIZE; 
                y = getHeight(pHeightMap, X + STEP_SIZE, Y ); 
                z = Y;
                <span class=comment>// Set the color value of the current vertice
</span>                setVertexColour(pHeightMap, x, z);
<span class=keyword>if</span>(X == STEP_SIZE &amp;&amp; Y == 0)
    glColor3ub(255, 255, 255);
                glVertex3i(x, y, z);            <span class=comment>// Send this vertex to OpenGL to be rendered
</span>            }
        }

    glEnd();

    <span class=comment>// Reset the color
</span>    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

}

<span class=comment>/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *
</span><span class=comment>/////////////////////////////////////////////////////////////////////////////////
</span><span class=comment>//
</span><span class=comment>// * QUICK NOTES * 
</span><span class=comment>//
</span><span class=comment>// Though being one of the simplest ways to display terrain from a height map,
</span><span class=comment>// it's a good start.  The next step we would take would be to make a quad tree
</span><span class=comment>// that only displayed the vertices that we could see from our view frustum.
</span><span class=comment>// This would allow us to display large terrains, but not have to push so many polygons.
</span><span class=comment>// This is a form of space partitioning.  There isn't as many good places to learn
</span><span class=comment>// about space partitioning as I would like, but the best place is www.GameInstitute.com.
</span><span class=comment>// They have an excellent terrain rendering course that deals with all of these problems,
</span><span class=comment>// including line of sight, terrain rendering techniques, adaptable meshes, geomorphing, etc..
</span><span class=comment>// 
</span><span class=comment>// Let's go over the steps that we accomplished during this tutorial
</span><span class=comment>//
</span><span class=comment>// 1) First, we need to read the height map from the .raw file.  This is simple because
</span><span class=comment>//    there is no header to a .raw file, it is just the image bits.  This file format
</span><span class=comment>//    isn't what you generally want to use because you have to either know what the
</span><span class=comment>//    size and type are, or guess, but I thought it fitting for this tutorial.
</span><span class=comment>// 
</span><span class=comment>// 2) After we read our height map data, we then needed to display it.  This was
</span><span class=comment>//    also a simple function because we are just making QUADS with a set size.
</span><span class=comment>//    I chose to do 16 by 16 quads, but you can change this to what ever you want.
</span><span class=comment>//    With our height map array, we treated it as a 2D array and did 2 for loops
</span><span class=comment>//    to draw each quad for each row and column.  Instead of doing lighting, I
</span><span class=comment>//    just gave each vertex a green intensity. depending on it's height.  This makes
</span><span class=comment>//    the terrain look like there is lighting applied.  This also makes it easier to
</span><span class=comment>//    see the definition in the terrain until lighting and texture maps are applied.
</span><span class=comment>//    
</span><span class=comment>// 
</span><span class=comment>// That's pretty much it.  As for doing texturing, this would be a good way to do
</span><span class=comment>// texture tiling.  You can go into a paint program and create a blank
</span><span class=comment>// file the size of your height map.  This will allow you to set up your textures
</span><span class=comment>// to see how you want it to look.  Then, make a 2D array that stores an index
</span><span class=comment>// into your texture array, then just bind that texture to the current quad that matches. 
</span><span class=comment>// it's X and Y position.  Maybe we will write a tutorial on this. 
</span><span class=comment>// 
</span><span class=comment>// The other option is to let OpenGL find the texture coordinates for you, or you can
</span><span class=comment>// find them yourself by stretching a texture over the whole thing (which isn't always desirable),
</span><span class=comment>// or wrap it.  Remember, (0, 0) is the top left corner and (1,1) is the bottom right corner.
</span><span class=comment>// You will have to find the ratio you want to wrap it with.  Here is an example:
</span><span class=comment>// 
</span><span class=comment>// glTexCoord2f(   (float)x / (float)MAP_SIZE,    
</span><span class=comment>//                 - (float)z / (float)MAP_SIZE    );
</span><span class=comment>//
</span><span class=comment>// Make sure you cast integers to floats when necessary otherwise it will truncate it.
</span><span class=comment>// The z is actually the Y value of the height map, but the z value in world coordinates.
</span><span class=comment>// Check out the next height map tutorial to see texturing a height map in action,
</span><span class=comment>// along with rendering the terrain using triangle strips.
</span><span class=comment>//
</span><span class=comment>// Good luck!
</span><span class=comment>//
</span><span class=comment>//
</span><span class=comment>// Ben Humphrey (DigiBen)
</span><span class=comment>// Game Programmer
</span><span class=comment>// DigiBen@GameTutorials.com
</span><span class=comment>// Co-Web Host of www.GameTutorials.com
</span><span class=comment>//
</span></pre></body>
</html>
