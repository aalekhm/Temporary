<html>
<head>
<style>
.keyword{color:rgb(0,0,255);}
.comment{color:rgb(0,128,0);}
.pp{color:rgb(0,0,255);}
</style>
<body>
<pre style="font-family:courier;font-size:10pt">
<span class=pp>#include</span> &lt;windows.h&gt;                    <span class=comment>// Header File For Windows
</span><span class=pp>#include</span> &lt;gl\gl.h&gt;                        <span class=comment>// Header File For The OpenGL32 Library
</span><span class=pp>#include</span> &lt;gl\glu.h&gt;                        <span class=comment>// Header File For The GLu32 Library
</span><span class=pp>#include</span> &lt;stdio.h&gt;
<span class=pp>#include</span> &lt;math.h&gt;
<span class=pp>#include</span> &lt;conio.h&gt;

<span class=pp>#include</span> &quot;main.h&quot;
<span class=pp>#include</span> &quot;MD3.h&quot;

HDC            mHDC        = NULL;            <span class=comment>// Private GDI Device Context
</span>HGLRC        mHRC        = NULL;            <span class=comment>// Permanent Rendering Context
</span>HWND        mHWnd        = NULL;                <span class=comment>// Holds Our Window Handle
</span>HINSTANCE    mHInstance;                    <span class=comment>// Holds The Instance Of The Application
</span>
<span class=keyword>bool</span>        mKeys[256];                    <span class=comment>// Array Used For The Keyboard Routine
</span><span class=keyword>bool</span>        mActive = <span class=keyword>false</span>;            <span class=comment>// Window Active Flag
</span><span class=keyword>bool</span>        mFULLSCREEN = <span class=keyword>true</span>;            <span class=comment>// Fullscreen Flag Set To TRUE By Default
</span>
<span class=keyword>int</span> cameraRotX, cameraRotY, cameraRotZ;
<span class=keyword>float</span> cameraPosX, cameraPosY, cameraPosZ;
<span class=keyword>const</span> <span class=keyword>float</span> piOver180 = 0.0174532925f;
<span class=keyword>const</span> <span class=keyword>float</span> MOVE_SPEED = 0.15f;
<span class=keyword>static</span> <span class=keyword>bool</span> L_MOUSE_DOWN = <span class=keyword>false</span>;

<span class=keyword>bool</span> upPressed;
<span class=keyword>int</span> loadedTextureCount = 0;

<span class=comment>//MD3 related
</span><span class=pp>#define</span>        MODEL_PATH    &quot;lara&quot;
<span class=pp>#define</span>        MODEL_NAME  &quot;lara&quot;
<span class=pp>#define</span>        GUN_NAME    &quot;railgun&quot;

CMD3Model    *gMD3Model;

<span class=keyword>int</span> glViewMode = GL_TRIANGLES;
<span class=keyword>float</span> rotateFaceY = 0.0;
<span class=keyword>int</span> CURRENT_FRAME_ID = 0;

<span class=keyword>bool</span> g_RenderMode = <span class=keyword>false</span>;

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
GL<span class=keyword>void</span>    resizeGLScene(GLsizei width, GLsizei height);
<span class=keyword>int</span> initGL(GL<span class=keyword>void</span>);
<span class=keyword>int</span> drawGLScene(GL<span class=keyword>void</span>);
GL<span class=keyword>void</span> killGLWindow(GL<span class=keyword>void</span>);
<span class=keyword>bool</span> createGLWindow(<span class=keyword>char</span>* title, <span class=keyword>int</span> width, <span class=keyword>int</span> height, <span class=keyword>int</span> bits, <span class=keyword>bool</span> isFullScreen);

<span class=keyword>void</span> checkMouseMovement() {
    <span class=keyword>if</span>(!L_MOUSE_DOWN)
        <span class=keyword>return</span>;

    <span class=keyword>int</span> screenCenterX = SCREEN_WIDTH&gt;&gt;1;
    <span class=keyword>int</span> screenCenterY = SCREEN_HEIGHT&gt;&gt;1;

    POINT mousePos;
    GetCursorPos(&amp;mousePos);
    
    <span class=comment>//Mouse not moved, hence return;
</span>    <span class=keyword>if</span>(mousePos.x == screenCenterX &amp;&amp; mousePos.y == screenCenterY)
        <span class=keyword>return</span>;

    SetCursorPos(screenCenterX, screenCenterY);
    
    <span class=comment>//Move, Rotate as proportinal to the displacement
</span>    <span class=keyword>float</span> deltaX = (mousePos.x - screenCenterX)/5.0f;
    <span class=keyword>float</span> deltaY = (mousePos.y - screenCenterY)/5.0f;
    
    cameraRotX -= deltaY;
    cameraRotY -= deltaX;
}

<span class=keyword>void</span> checkKeyboardMovement() {
    <span class=keyword>if</span>(mKeys['Q'] || mKeys[VK_LEFT]) {
        cameraRotY = (cameraRotY + 1) % 360;
    }
    <span class=keyword>if</span>(mKeys['E'] || mKeys[VK_RIGHT]) {
        cameraRotY = (cameraRotY - 1) % 360;
    }
    <span class=keyword>if</span>(mKeys['W']) {
        cameraPosX -= sin( cameraRotY * piOver180 ) * MOVE_SPEED;
        cameraPosZ -= cos( cameraRotY * piOver180 ) * MOVE_SPEED;
    }
    <span class=keyword>if</span>(mKeys['S']) {
        cameraPosX += sin( cameraRotY * piOver180 ) * MOVE_SPEED;
        cameraPosZ += cos( cameraRotY * piOver180 ) * MOVE_SPEED;
    }
    <span class=keyword>if</span>(mKeys['A']) {
        cameraPosX += sin( (cameraRotY-90) * piOver180 ) * MOVE_SPEED;
        cameraPosZ += cos( (cameraRotY-90) * piOver180 ) * MOVE_SPEED;
    }
    <span class=keyword>if</span>(mKeys['D']) {
        cameraPosX -= sin( (cameraRotY-90) * piOver180 ) * MOVE_SPEED;
        cameraPosZ -= cos( (cameraRotY-90) * piOver180 ) * MOVE_SPEED;
    }
    <span class=keyword>if</span>(mKeys[VK_UP]) {
        cameraRotX = (cameraRotX + 1) % 360;
    }
    <span class=keyword>if</span>(mKeys[VK_DOWN]) {
        cameraRotX = (cameraRotX - 1) % 360;
    }
}

<span class=keyword>void</span> updateCamera(<span class=keyword>void</span>) {
    checkMouseMovement();
    checkKeyboardMovement();
}

<span class=comment>/*PITCH - Rotation around X - axis */</span>
<span class=keyword>void</span> cameraPitch(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 1.0f, 0.0f, 0.0f);
}

<span class=comment>/*YAW - Rotation around Y - axis */</span>
<span class=keyword>void</span> cameraYaw(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 0.0f, 1.0f, 0.0f);
}

<span class=comment>/*ROLL - Rotation around Z - axis */</span>
<span class=keyword>void</span> cameraRoll(<span class=keyword>float</span> rotation) {
    glRotatef(rotation, 0.0f, 0.0f, 1.0f);
}

<span class=keyword>void</span> cameraMoveTo(<span class=keyword>float</span> xTranslate, <span class=keyword>float</span> yTranslate, <span class=keyword>float</span> zTranslate) {
    glTranslatef(xTranslate, yTranslate, zTranslate);
}

<span class=keyword>void</span> moveCamera(<span class=keyword>void</span>) {
    <span class=comment>//Player Camera - Rotation
</span>    cameraPitch(-cameraRotX);
    cameraYaw(-cameraRotY);
    cameraRoll(-cameraRotZ);

    <span class=comment>//Player Camera - Translation
</span>    cameraMoveTo(-cameraPosX, -cameraPosY, -cameraPosZ);
}

<span class=keyword>void</span> handleKeyboard(<span class=keyword>void</span>) {
    <span class=keyword>if</span>(mKeys[VK_F1]) {
        mKeys[VK_F1] = <span class=keyword>false</span>;
        killGLWindow();
        mFULLSCREEN = !mFULLSCREEN;
        <span class=keyword>if</span>(!createGLWindow(&quot;openGL window&quot;, 640, 480, 16, mFULLSCREEN)) {
            <span class=keyword>return</span>;
        }
    }
}


<span class=keyword>int</span> WINAPI WinMain(    HINSTANCE    hInstance, 
                    HINSTANCE    hPrevInstance,
                    LPSTR        lpCmdLine,
                    <span class=keyword>int</span>            nCmdShow
) {
    MSG        msg;
    <span class=keyword>bool</span>    done = <span class=keyword>false</span>;

    <span class=comment>//if(MessageBox(NULL, &quot;Would you like to run in FULLSCREEN mode?&quot;, &quot;Start FullScreen&quot;, MB_YESNO) == IDNO)
</span>        mFULLSCREEN = <span class=keyword>false</span>;

    <span class=keyword>if</span>(!createGLWindow(&quot;openGL Window...Press F1 to toogle between windowed &amp; Fullscreen Mode.&quot;, 640, 480, 16, mFULLSCREEN))
        <span class=keyword>return</span> 0;

    <span class=keyword>while</span>(!done) {
        <span class=keyword>if</span>(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
            <span class=keyword>if</span>(msg.message == WM_QUIT)
                done = <span class=keyword>true</span>;
            <span class=keyword>else</span>  {
                TranslateMessage(&amp;msg);
                DispatchMessage(&amp;msg);
            }
        }
        <span class=keyword>else</span> {
            <span class=keyword>if</span>(mActive) {
                <span class=keyword>if</span>(mKeys[VK_ESCAPE])
                    done = <span class=keyword>true</span>;
                <span class=keyword>else</span> {
                    drawGLScene();
                    SwapBuffers(mHDC);
                }
            }

            updateCamera();
            handleKeyboard();
        }
    }

    killGLWindow();
    <span class=keyword>return</span> msg.wParam;
}

<span class=keyword>bool</span> createGLWindow(<span class=keyword>char</span>* title, <span class=keyword>int</span> width, <span class=keyword>int</span> height, <span class=keyword>int</span> bits, <span class=keyword>bool</span> isFullScreen) {
    <span class=keyword>int</span>            iPixelFormat;
    WNDCLASS    wc;
    DWORD        dwExStyle;
    DWORD        dwStyle;
    RECT        windowRect;

    windowRect.left        = (<span class=keyword>long</span>)0;
    windowRect.right    = (<span class=keyword>long</span>)width;
    windowRect.top        = (<span class=keyword>long</span>)0;
    windowRect.bottom    = (<span class=keyword>long</span>)height;

    mFULLSCREEN = isFullScreen;

    mHInstance            = GetModuleHandle(NULL);
    
    wc.cbClsExtra        = 0;
    wc.cbWndExtra        = 0;
    wc.hbrBackground    = NULL;
    wc.hCursor            = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = LoadIcon(NULL, IDI_WINLOGO);
    wc.hInstance        = mHInstance;
    wc.lpfnWndProc        = (WNDPROC) WndProc;
    wc.lpszClassName    = &quot;OpenGL&quot;;
    wc.lpszMenuName        = NULL;
    wc.style            = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    
    <span class=keyword>if</span>(!RegisterClass(&amp;wc)) {
        MessageBox(NULL, &quot;Failed to Register the Window Class.&quot;, &quot;ERROR&quot;, MB_OK | MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;
    }

    <span class=keyword>if</span>(mFULLSCREEN) {
        DEVMODE    dmScreenSettings;
        memset(&amp;dmScreenSettings, 0, <span class=keyword>sizeof</span>(dmScreenSettings));
        dmScreenSettings.dmSize            = <span class=keyword>sizeof</span>(dmScreenSettings);
        dmScreenSettings.dmPelsWidth    = width;
        dmScreenSettings.dmPelsHeight    = height;
        dmScreenSettings.dmBitsPerPel    = bits;
        dmScreenSettings.dmFields        = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

        <span class=keyword>if</span>(ChangeDisplaySettings(&amp;dmScreenSettings, CDS_FULLSCREEN) != DISP_CHANGE_SUCCESSFUL) {
            <span class=keyword>if</span>(MessageBox(NULL, &quot;The requested FullScreen Mode is not supported\n by your Video Card. Use Windowed Mode instead?&quot;, &quot;Error&quot;, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
                mFULLSCREEN = <span class=keyword>false</span>;
            <span class=keyword>else</span> {
                MessageBox(NULL, &quot;Program will now close.&quot;, &quot;ERROR&quot;, MB_OK | MB_ICONSTOP);
                <span class=keyword>return</span> <span class=keyword>false</span>;
            }
        }
    }
    
    ShowCursor(!<span class=keyword>false</span>);

    <span class=keyword>if</span>(mFULLSCREEN) {
        dwExStyle    = WS_EX_APPWINDOW;
        dwStyle        = WS_POPUP;
    }
    <span class=keyword>else</span> {
        dwExStyle    = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
        dwStyle        = WS_OVERLAPPEDWINDOW;
    }

    AdjustWindowRectEx(&amp;windowRect, dwStyle, <span class=keyword>false</span>, dwExStyle);

    <span class=keyword>if</span>(!(mHWnd = CreateWindowEx(    dwExStyle,
                                &quot;OpenGL&quot;,
                                title,
                                dwStyle | 
                                WS_CLIPSIBLINGS |
                                WS_CLIPCHILDREN,
                                0, 0,
                                windowRect.right - windowRect.left,
                                windowRect.bottom - windowRect.top,
                                NULL,
                                NULL,
                                mHInstance,
                                NULL))
    ) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Window Creation Error.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }

    <span class=keyword>if</span>(!(mHDC = GetDC(mHWnd))) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Unable to get Device Context.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }
    
    <span class=keyword>static</span> PIXELFORMATDESCRIPTOR pfd = 
    {
        <span class=keyword>sizeof</span>(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW |
        PFD_SUPPORT_OPENGL |
        PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        bits,
        0, 0, 0, 0, 0, 0,
        0,
        0,
        0,
        0, 0, 0, 0,
        16,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0, 0, 0
    };

    <span class=keyword>if</span>(!(iPixelFormat = ChoosePixelFormat(mHDC, &amp;pfd))) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Unable to choose Pixel format.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }

    <span class=keyword>if</span>(!SetPixelFormat(mHDC, iPixelFormat, &amp;pfd)) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Unable to set Pixel format.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }

    <span class=keyword>if</span>(!(mHRC = wglCreateContext(mHDC))) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Unable to create wgl context.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }

    <span class=keyword>if</span>(!wglMakeCurrent(mHDC, mHRC)) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Unable to make wgl context&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }
                                
    ShowWindow(mHWnd, <span class=keyword>true</span>);
    SetForegroundWindow(mHWnd);
    SetFocus(mHWnd);

    resizeGLScene(width, height);

    <span class=keyword>if</span>(!initGL()) {
        killGLWindow();                                <span class=comment>// Reset The Display
</span>        MessageBox(NULL,&quot;Window Creation Error.&quot;,&quot;ERROR&quot;,MB_OK|MB_ICONEXCLAMATION);
        <span class=keyword>return</span> <span class=keyword>false</span>;                                <span class=comment>// Return FALSE
</span>    }
    
    <span class=keyword>return</span> <span class=keyword>true</span>;
}

GL<span class=keyword>void</span> resizeGLScene(GLsizei width, GLsizei height) {
    <span class=keyword>if</span>(height == 0)
        height = 1;

    glViewport(0, 0, width, height);
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    gluPerspective(45.0f, (GL<span class=keyword>float</span>)width/(GL<span class=keyword>float</span>)height, 0.1f, 150.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

<span class=keyword>int</span> initGL(GL<span class=keyword>void</span>) {
    mLogFile = fopen(&quot;console.log&quot;, &quot;wb&quot;);

    <span class=comment>//////////// *** NEW *** ////////// *** NEW *** ///////////// *** NEW *** ////////////////////
</span>    <span class=comment>// To load a Quake3 character it's as simple as a first grade math test.  With our
</span>    <span class=comment>// g_Model instance, we just pass in the path and the character name prefix to LoadModel().
</span>    <span class=comment>// If we want, we can check the result to see if the character was loaded.
</span>
    <span class=comment>// Load the 3 body part meshes and their skins and texture
</span>    gMD3Model = <span class=keyword>new</span> CMD3Model();
    <span class=keyword>bool</span> bResult = gMD3Model-&gt;loadModel(MODEL_PATH, MODEL_NAME);

    <span class=comment>// Next, if we want to give our character a gun, we just pass in the name of the gun
</span>    <span class=comment>// and the path it's stored in.  I just stuck the gun in the same path as our character.
</span>
    <span class=comment>// Load the gun and attach it to our character
</span>    bResult = gMD3Model-&gt;loadWeapon(MODEL_PATH, GUN_NAME);

    <span class=comment>//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ NEW
</span>    <span class=comment>// When we get here, the character should have everything loaded.  Before going on,
</span>    <span class=comment>// we want to set the current animation for the torso and the legs.
</span>
    <span class=comment>// Set the standing animation for the torso
</span>    gMD3Model-&gt;setTorsoAnimation(&quot;TORSO_STAND&quot;);

    <span class=comment>// Set the walking animation for the legs
</span>    gMD3Model-&gt;setLegsAnimation(&quot;LEGS_WALK&quot;);
    <span class=comment>//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ NEW
</span>
    <span class=comment>//////////// *** NEW *** ////////// *** NEW *** ///////////// *** NEW *** ////////////////////
</span>
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_COLOR_MATERIAL);                        <span class=comment>// Allow color
</span>    
    <span class=comment>///////////////////////////////////
</span>    glShadeModel(GL_SMOOTH);
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);
    glClearDepth(1.0f);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    glEnable(GL_CULL_FACE);                                <span class=comment>// Turn culling on
</span>    glCullFace(GL_FRONT);                                <span class=comment>// Quake2 uses front face culling apparently
</span>
    <span class=keyword>return</span> <span class=keyword>true</span>;
}

GL<span class=keyword>void</span> killGLWindow() {
    <span class=keyword>if</span>(mFULLSCREEN) {
        ChangeDisplaySettings(NULL, 0);
        ShowCursor(<span class=keyword>true</span>);
    }

    <span class=keyword>if</span>(mHRC) {
        <span class=keyword>if</span>(!wglMakeCurrent(NULL, NULL))
            MessageBox(NULL, &quot;Release of DC and RC failed.&quot;, &quot;SHUTDOWN ERROR&quot;, MB_OK | MB_ICONINFORMATION);

        <span class=keyword>if</span>(!wglDeleteContext(mHRC))
            MessageBox(NULL, &quot;Release of DC and RC failed.&quot;, &quot;SHUTDOWN ERROR&quot;, MB_OK | MB_ICONINFORMATION);

        mHRC = NULL;
    }

    <span class=keyword>if</span>(mHDC &amp;&amp; !ReleaseDC(mHWnd, mHDC)) {
        MessageBox(NULL, &quot;Release of Device Context failed.&quot;, &quot;SHUTDOWN ERROR&quot;, MB_OK | MB_ICONINFORMATION);
        mHDC = NULL;
    }

    <span class=keyword>if</span>(mHWnd &amp;&amp; !DestroyWindow(mHWnd)) {
        MessageBox(NULL, &quot;Release of mHWnd failed.&quot;, &quot;SHUTDOWN ERROR&quot;, MB_OK | MB_ICONINFORMATION);
        mHWnd = NULL;
    }

    <span class=keyword>if</span>(!UnregisterClass(&quot;OpenGL&quot;, mHInstance)) {
        MessageBox(NULL, &quot;UnRegisterClass failed.&quot;, &quot;SHUTDOWN ERROR&quot;, MB_OK | MB_ICONINFORMATION);
        mHInstance = NULL;
    }
}

<span class=keyword>int</span> drawGLScene() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    moveCamera();

    glTranslatef(0.0, -0.0, -85.0f);
    <span class=comment>//glRotatef(rotateFaceY, 0.0, 1.0, 0.0);
</span>
    gMD3Model-&gt;drawModel();
    
    <span class=comment>//rotateFaceY = (float)(((UINT)rotateFaceY + 1) % 360);
</span>
    <span class=keyword>return</span> <span class=keyword>true</span>;
}

<span class=comment>//This function increases the model's torso or legs animation
</span><span class=keyword>void</span> increaseCharacterAnimation(CMD3Model *pCharacter, <span class=keyword>int</span> whichPart) {

    <span class=keyword>char</span> strWindowTitle[255] = {0};
    t3DModel *pModel, *pUpper, *pLower;

    <span class=comment>// This function doesn't have much to do with the character animation, but I
</span>    <span class=comment>// created it so that we can cycle through each of the animations to see how
</span>    <span class=comment>// they all look.  You can press the right and left mouse buttons to cycle through
</span>    <span class=comment>// the torso and leg animations.  If the current animation is the end animation,
</span>    <span class=comment>// it cycles back to the first animation.  This function takes the character you
</span>    <span class=comment>// want, then the define (kLower, kUpper) that tells which part to change.
</span>
    <span class=comment>// Here we store pointers to the legs and torso, so we can display their current anim name
</span>    pLower = pCharacter-&gt;getModel(kLower);
    pUpper = pCharacter-&gt;getModel(kUpper);

    <span class=comment>// This line gives us a pointer to the model that we want to change
</span>    pModel = pCharacter-&gt;getModel(whichPart);

    <span class=comment>// To cycle through the animations, we just increase the model's current animation
</span>    <span class=comment>// by 1.  You'll notice that we also mod this result by the total number of
</span>    <span class=comment>// animations in our model, to make sure we go back to the beginning once we reach
</span>    <span class=comment>// the end of our animation list.  
</span>
    <span class=comment>// Increase the current animation and mod it by the max animations
</span>    pModel-&gt;currentAnim = (pModel-&gt;currentAnim + 1) % (pModel-&gt;numOfAnimations);

    <span class=comment>// Set the current frame to be the starting frame of the new animation
</span>    pModel-&gt;nextFrame = pModel-&gt;pAnimations[pModel-&gt;currentAnim].startFrame;

    <span class=comment>// (* NOTE *) Currently when changing animations, the character doesn't immediately
</span>    <span class=comment>// change to the next animation, but waits till it finishes the current animation
</span>    <span class=comment>// and slowly blends into the next one.  If you want an immediate switch, change
</span>    <span class=comment>// the pModel-nextFrame to pModel-&gt;currentFrame.
</span>
    <span class=comment>// Display the current animations in our window's title bar
</span>    sprintf(strWindowTitle, &quot;www.GameTutorials.com - Md3 Animation:   Lower: %s  Upper: %s&quot;, 
            pLower-&gt;pAnimations[pLower-&gt;currentAnim].animationName, 
            pUpper-&gt;pAnimations[pUpper-&gt;currentAnim].animationName
        );

    <span class=comment>// Set the window's title bar to our new string of animation names
</span>    SetWindowText(mHWnd, strWindowTitle);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    <span class=keyword>switch</span>(uMsg) {
        <span class=keyword>case</span> WM_CREATE:
        {
            SetCursorPos(SCREEN_WIDTH&gt;&gt;1, SCREEN_HEIGHT&gt;&gt;1);
            <span class=keyword>return</span> 0;
        }
        <span class=keyword>break</span>;
        <span class=keyword>case</span> WM_ACTIVATE:
        {
            <span class=keyword>if</span>(!HIWORD(wParam))
                mActive = <span class=keyword>true</span>;
            <span class=keyword>else</span>
                mActive = <span class=keyword>false</span>;

            <span class=keyword>return</span> 0;
        }
        <span class=keyword>case</span> WM_SYSCOMMAND:
        {
            <span class=keyword>switch</span>(wParam) {
                <span class=keyword>case</span> SC_SCREENSAVE:
                <span class=keyword>case</span> SC_MONITORPOWER:
                    <span class=keyword>return</span> 0;
            }
        }
        <span class=keyword>break</span>;
        <span class=keyword>case</span> WM_CLOSE:
        {
            PostQuitMessage(0);
            <span class=keyword>return</span> 0;
        }
        <span class=keyword>case</span> WM_KEYDOWN:
        {
            mKeys[wParam] = <span class=keyword>true</span>;
            <span class=keyword>return</span> 0;
        }
        <span class=keyword>case</span> WM_KEYUP:
        {
            mKeys[wParam] = <span class=keyword>false</span>;
            <span class=keyword>return</span> 0;
        }
        <span class=keyword>case</span> WM_SIZE:
        {
            resizeGLScene(LOWORD(lParam), HIWORD(lParam));
            <span class=keyword>return</span> 0;
        }
        <span class=keyword>case</span> WM_LBUTTONDOWN:
        {
            SetCursorPos(SCREEN_WIDTH&gt;&gt;1, SCREEN_HEIGHT&gt;&gt;1);
            L_MOUSE_DOWN = <span class=keyword>true</span>;
        }
        <span class=keyword>break</span>;
        <span class=keyword>case</span> WM_LBUTTONUP:        
        {
            L_MOUSE_DOWN = <span class=keyword>false</span>;
            
            <span class=comment>// Increase the leg's current animation to the next animation
</span>            increaseCharacterAnimation( gMD3Model, kLower);

            <span class=comment>//glViewMode = (glViewMode == GL_TRIANGLES)?GL_LINES:GL_TRIANGLES;
</span>        }
        <span class=keyword>break</span>;
        <span class=keyword>case</span> WM_RBUTTONDOWN:
            <span class=comment>///*
</span>            g_RenderMode = !g_RenderMode;    <span class=comment>// Change the rendering mode
</span>
            <span class=comment>// Change the rendering mode to and from lines or triangles
</span>            <span class=keyword>if</span>(g_RenderMode) {
                <span class=comment>// Render the triangles in fill mode        
</span>                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);    
            }
            <span class=keyword>else</span> {
                <span class=comment>// Render the triangles in wire frame mode
</span>                glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
            }
            <span class=comment>//*/
</span>
            <span class=comment>// Increase the torso's current animation to the next animation
</span>            increaseCharacterAnimation( gMD3Model, kUpper );
        <span class=keyword>break</span>;
    }

    <span class=keyword>return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);
}</pre></body>
</html>
